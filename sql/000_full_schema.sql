-- Installazione completa Flow Starter (Core + Billing)
-- Esegui questo file una sola volta su un progetto nuovo.

-- Estensioni necessarie
create extension if not exists pgcrypto;

-- =============================
-- CORE SCHEMA
-- =============================

-- Tabella profili utente (se non esiste)
create table if not exists public.profiles (
  id uuid primary key,
  email text,
  credits numeric default 0,
  openrouter_api_key text,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now()
);

-- Se la tabella esiste giÃ  senza la colonna, aggiungila (installazioni precedenti)
alter table public.profiles add column if not exists openrouter_api_key text;

-- Tabella ledger transazioni crediti
create table if not exists public.credit_transactions (
  id bigint generated by default as identity primary key,
  user_id uuid not null,
  amount numeric not null,
  reason text,
  created_at timestamp with time zone default now()
);

-- Indice per performance
create index if not exists idx_credit_tx_user_id on public.credit_transactions(user_id);

-- Estensioni avanzate del ledger (compatibili con schema esistente)
alter table public.credit_transactions add column if not exists operation_type text; -- es. 'system' | 'user_action' | 'webhook'
alter table public.credit_transactions add column if not exists operation_name text;  -- es. 'monthly_rollout' | 'openrouter_debit'
alter table public.credit_transactions add column if not exists context jsonb default '{}'::jsonb;
alter table public.credit_transactions add column if not exists reference_id text;
alter table public.credit_transactions add column if not exists reference_type text;
alter table public.credit_transactions add column if not exists updated_at timestamp with time zone default now();
create index if not exists idx_credit_tx_user_created on public.credit_transactions(user_id, created_at);

-- Chiavi OpenRouter per-utente (mapping user -> key_name)
create table if not exists public.openrouter_user_keys (
  user_id uuid primary key,
  key_name text not null,
  created_at timestamp with time zone default now()
);

-- Abilita RLS anche per le chiavi OpenRouter e consenti lettura solo al proprietario
alter table public.openrouter_user_keys enable row level security;
do $$ begin
  begin
    create policy openrouter_keys_select_self on public.openrouter_user_keys
      for select using (user_id = auth.uid());
  exception when duplicate_object then null; end;
end $$;

-- Configurazioni Flowise per multi-tenant: mapping flow_key -> flow_id, node_names per app
create table if not exists public.flow_configs (
  app_id text not null,
  flow_key text not null,
  flow_id text not null,
  node_names jsonb default '[]'::jsonb,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now(),
  primary key (app_id, flow_key)
);

alter table public.flow_configs enable row level security;
-- Policy di esempio: nessun accesso client; accesso solo via service role
do $$ begin
  begin
    create policy flow_configs_deny_all on public.flow_configs for all
      using (false) with check (false);
  exception when duplicate_object then null; end;
end $$;

-- Funzione atomica per addebitare crediti
create or replace function public.debit_user_credits(
  p_user_id uuid,
  p_amount numeric,
  p_reason text default 'debit'
) returns json as $$
declare
  v_before numeric;
  v_after numeric;
begin
  if p_amount is null or p_amount <= 0 then
    return json_build_object('success', false, 'error', 'invalid_amount');
  end if;

  select credits into v_before from public.profiles where id = p_user_id for update;
  if v_before is null then
    return json_build_object('success', false, 'error', 'user_not_found');
  end if;
  if v_before < p_amount then
    return json_build_object('success', false, 'error', 'insufficient_credits', 'available', v_before, 'required', p_amount);
  end if;

  v_after := v_before - p_amount;
  update public.profiles set credits = v_after, updated_at = now() where id = p_user_id;

  -- Inserimento avanzato nel ledger con metadati
  insert into public.credit_transactions(
    user_id, amount, reason, operation_type, operation_name, context, reference_id, reference_type, created_at, updated_at
  ) values (
    p_user_id, -p_amount, p_reason, 'system', coalesce(p_reason, 'debit'), '{}'::jsonb, null, null, now(), now()
  );

  return json_build_object('success', true, 'credits_before', v_before, 'credits_after', v_after);
end;
$$ language plpgsql security definer;

-- Policy raccomandate (RLS da adattare al contesto)
alter table public.profiles enable row level security;
alter table public.credit_transactions enable row level security;

-- Esempio policy: accesso in lettura al proprio record (da adattare a auth.uid())
do $$ begin
  begin
    create policy profiles_select_self on public.profiles
      for select using (id = auth.uid());
  exception when duplicate_object then null; end;
  begin
    create policy credit_tx_select_self on public.credit_transactions
      for select using (user_id = auth.uid());
  exception when duplicate_object then null; end;
end $$;

-- Creazione organica profilo alla registrazione (trigger su auth.users)
create or replace function public.handle_new_user_profile()
returns trigger as $$
begin
  insert into public.profiles (id, email, credits, created_at, updated_at)
  values (new.id, new.email, 0, now(), now())
  on conflict (id) do nothing;
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_auth_user_created_profile on auth.users;
create trigger on_auth_user_created_profile
after insert on auth.users
for each row execute function public.handle_new_user_profile();

-- Tabella pricing per-app: configurazione pricing in JSONB
create table if not exists public.pricing_configs (
  app_id text primary key,
  config jsonb not null default '{}'::jsonb,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now()
);

alter table public.pricing_configs enable row level security;
do $$ begin
  begin
    create policy pricing_configs_deny_all on public.pricing_configs for all
      using (false) with check (false);
  exception when duplicate_object then null; end;
end $$;

create index if not exists idx_flow_configs_app on public.flow_configs(app_id);
create index if not exists idx_pricing_configs_updated_at on public.pricing_configs(updated_at);


-- =============================
-- BILLING SCHEMA (provider-agnostico)
-- =============================

-- Catalogo piani (strutturato) e abbonamenti utente (stato per-utente)
create table if not exists public.subscription_plans (
  id varchar primary key,
  name varchar not null,
  type varchar not null check (type in ('subscription','pay_as_go','enterprise','credits','custom')),
  credits_per_month integer not null,
  price_per_month numeric not null,
  rollout_percentage numeric not null default 0.0,
  discount_percentage numeric not null default 0.0,
  description text,
  ideal_for varchar,
  popular boolean default false,
  badge varchar,
  color varchar default 'border-blue-300',
  icon varchar default 'ðŸ’³',
  is_active boolean default true,
  min_commitment_months integer default 1,
  max_credits_rollover integer,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists public.subscriptions (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null,
  plan_id varchar not null references public.subscription_plans(id),
  provider varchar not null default 'lemonsqueezy',
  provider_subscription_id varchar not null,
  status varchar not null default 'active' check (status in ('active','cancelled','past_due','paused')),
  current_period_start timestamptz not null,
  current_period_end timestamptz not null,
  credits_per_month integer not null,
  price_per_month numeric not null,
  rollout_percentage numeric not null default 0.0,
  credits_remaining integer default 0,
  metadata jsonb default '{}'::jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  user_fk constraint subscriptions_user_id_fkey references public.profiles(id)
);

create index if not exists idx_subscriptions_user on public.subscriptions(user_id);

-- Audit dei cicli di rollout crediti
create table if not exists public.credits_rollout_runs (
  id uuid primary key default gen_random_uuid(),
  run_timestamp timestamptz not null default now(),
  run_type varchar not null default 'scheduled', -- 'scheduled' | 'manual'
  users_processed integer not null default 0,
  users_successful integer not null default 0,
  users_failed integer not null default 0,
  total_credits_accredited numeric not null default 0,
  execution_time_seconds integer,
  success boolean not null default true,
  error_message text,
  config_snapshot jsonb
);

create index if not exists idx_credits_rollout_runs_time on public.credits_rollout_runs(run_timestamp);

-- Telemetria OpenRouter (usage per generazione e snapshot per utente)
create table if not exists public.openrouter_generations_log (
  id uuid primary key default gen_random_uuid(),
  user_id uuid,
  user_email text,
  endpoint_used text,
  model text,
  cost_usd numeric default 0.00,
  credits_charged integer default 0,
  openrouter_key_hash text,
  success boolean default true,
  error_message text,
  request_timestamp timestamptz default now(),
  created_at timestamptz default now(),
  response_time_ms integer default 0,
  prompt_tokens integer default 0,
  completion_tokens integer default 0,
  total_tokens integer default 0,
  model_name text
);

create index if not exists idx_or_generations_user_time on public.openrouter_generations_log(user_id, request_timestamp);

create table if not exists public.openrouter_usage_snapshot (
  user_id uuid primary key,
  last_snapshot_usd numeric not null default 0,
  updated_at timestamptz not null default now()
);

-- LemonSqueezy adapter tables (first-class) per debugging e riconciliazione
create table if not exists public.lemonsqueezy_customers (
  id uuid primary key default gen_random_uuid(),
  lemonsqueezy_customer_id varchar not null unique,
  user_id uuid references public.profiles(id),
  email varchar not null,
  name varchar,
  city varchar,
  region varchar,
  country varchar,
  total_revenue_currency varchar default 'USD',
  total_revenue_cents integer default 0,
  status varchar default 'active',
  last_sync_at timestamptz,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  raw_data jsonb
);

create table if not exists public.lemonsqueezy_transactions (
  id uuid primary key default gen_random_uuid(),
  lemonsqueezy_transaction_id varchar not null unique,
  lemonsqueezy_order_id varchar,
  lemonsqueezy_subscription_id varchar,
  lemonsqueezy_customer_id varchar,
  user_id uuid references public.profiles(id),
  subscription_id uuid references public.subscriptions(id),
  transaction_type varchar not null check (transaction_type in ('subscription','one_time','refund','chargeback')),
  amount_cents integer not null,
  currency varchar not null default 'USD',
  status varchar not null check (status in ('pending','paid','failed','refunded','disputed')),
  product_name varchar,
  variant_name varchar,
  credits_amount integer,
  payment_method varchar,
  card_brand varchar,
  card_last_four varchar,
  paid_at timestamptz,
  refunded_at timestamptz,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  raw_data jsonb
);

create index if not exists idx_ls_tx_user on public.lemonsqueezy_transactions(user_id);

create table if not exists public.lemonsqueezy_webhook_logs (
  id uuid primary key default gen_random_uuid(),
  webhook_id varchar not null,
  event_name varchar not null,
  status varchar not null default 'received' check (status in ('received','processed','failed','ignored')),
  processed_at timestamptz,
  error_message text,
  retry_count integer default 0,
  signature_valid boolean default true,
  signature_header text,
  payload jsonb not null,
  headers jsonb,
  received_at timestamptz default now(),
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- =============================
-- RLS E POLICY PER NUOVE TABELLE
-- =============================

-- Subscriptions: per-utente (select_self)
alter table public.subscriptions enable row level security;
do $$ begin
  begin
    create policy subscriptions_select_self on public.subscriptions
      for select using (user_id = auth.uid());
  exception when duplicate_object then null; end;
end $$;

-- Subscription plans: solo service_role (deny_all)
alter table public.subscription_plans enable row level security;
do $$ begin
  begin
    create policy subscription_plans_deny_all on public.subscription_plans for all
      using (false) with check (false);
  exception when duplicate_object then null; end;
end $$;

-- Credits rollout runs: solo service_role (deny_all)
alter table public.credits_rollout_runs enable row level security;
do $$ begin
  begin
    create policy credits_rollout_runs_deny_all on public.credits_rollout_runs for all
      using (false) with check (false);
  exception when duplicate_object then null; end;
end $$;

-- OpenRouter tables
alter table public.openrouter_generations_log enable row level security;
alter table public.openrouter_usage_snapshot enable row level security;
do $$ begin
  begin
    create policy or_generations_select_self on public.openrouter_generations_log
      for select using (user_id = auth.uid());
  exception when duplicate_object then null; end;
  begin
    create policy or_usage_snapshot_select_self on public.openrouter_usage_snapshot
      for select using (user_id = auth.uid());
  exception when duplicate_object then null; end;
end $$;

-- LemonSqueezy tables: solo service_role (deny_all)
alter table public.lemonsqueezy_customers enable row level security;
alter table public.lemonsqueezy_transactions enable row level security;
alter table public.lemonsqueezy_webhook_logs enable row level security;
do $$ begin
  begin
    create policy ls_customers_deny_all on public.lemonsqueezy_customers for all
      using (false) with check (false);
  exception when duplicate_object then null; end;
  begin
    create policy ls_transactions_deny_all on public.lemonsqueezy_transactions for all
      using (false) with check (false);
  exception when duplicate_object then null; end;
  begin
    create policy ls_webhook_logs_deny_all on public.lemonsqueezy_webhook_logs for all
      using (false) with check (false);
  exception when duplicate_object then null; end;
end $$;

-- =============================
-- SEED CONFIG INIZIALI (APP_ID = 'default')
-- =============================

-- pricing_configs seed (UPSERT)
insert into public.pricing_configs(app_id, config, created_at, updated_at)
values (
  'default',
  '{
    "rollout": {
      "interval": "monthly",
      "credits_per_period": 1000,
      "max_credits_rollover": 2000,
      "proration": "none",
      "rollout_percentage": 100
    },
    "llm_pricing": {
      "openrouter": {
        "gpt-4o-mini": { "credits_per_1k_tokens": 5 },
        "llama-3.1-8b": { "credits_per_1k_tokens": 1 }
      }
    },
    "plans": {
      "starter": { "credits_per_month": 1000, "price_per_month": 19 },
      "pro": { "credits_per_month": 5000, "price_per_month": 79 }
    }
  }'::jsonb,
  now(), now()
)
on conflict (app_id) do update set config = excluded.config, updated_at = now();

-- flow_configs seed (UPSERT)
insert into public.flow_configs(app_id, flow_key, flow_id, node_names, created_at, updated_at)
values
('default', 'demo_generate_intro', 'FLOW_DEMO_INTRO', '[]'::jsonb, now(), now()),
('default', 'demo_summarize', 'FLOW_DEMO_SUMMARY', '[]'::jsonb, now(), now())
on conflict (app_id, flow_key) do update set flow_id = excluded.flow_id, node_names = excluded.node_names, updated_at = now();

-- Tabella transazioni di billing (agnostica al provider)
create table if not exists public.billing_transactions (
  id uuid primary key default gen_random_uuid(),
  provider text not null, -- es. 'lemonsqueezy', 'paddle'
  provider_transaction_id text unique,
  provider_order_id text,
  provider_subscription_id text,
  provider_customer_id text,

  user_id uuid references public.profiles(id) on delete cascade,

  transaction_type text not null check (transaction_type in ('subscription','one_time','refund','chargeback')),
  amount_cents integer not null,
  currency varchar(3) not null default 'USD',
  status text not null check (status in ('pending','paid','failed','refunded','disputed')),

  product_name text,
  variant_name text,
  credits_amount integer,

  raw_data jsonb,

  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create index if not exists idx_billing_tx_provider_id on public.billing_transactions(provider_transaction_id);
create index if not exists idx_billing_tx_user on public.billing_transactions(user_id);
create index if not exists idx_billing_tx_provider on public.billing_transactions(provider);

-- Tabella logs webhook per audit/debug
create table if not exists public.billing_webhook_logs (
  id uuid primary key default gen_random_uuid(),
  provider text not null,
  payload jsonb not null,
  status text not null default 'received',
  error_message text,
  received_at timestamptz default now()
);

create index if not exists idx_billing_webhook_provider on public.billing_webhook_logs(provider);
create index if not exists idx_billing_webhook_status on public.billing_webhook_logs(status);
create index if not exists idx_billing_webhook_received on public.billing_webhook_logs(received_at);

-- Funzione atomica per accreditare crediti (complementare a debit_user_credits)
create or replace function public.credit_user_credits(
  p_user_id uuid,
  p_amount numeric,
  p_reason text default 'credit'
) returns json as $$
declare
  v_before numeric;
  v_after numeric;
begin
  if p_amount is null or p_amount <= 0 then
    return json_build_object('success', false, 'error', 'invalid_amount');
  end if;

  select credits into v_before from public.profiles where id = p_user_id for update;
  if v_before is null then
    return json_build_object('success', false, 'error', 'user_not_found');
  end if;

  v_after := coalesce(v_before, 0) + p_amount;
  update public.profiles set credits = v_after, updated_at = now() where id = p_user_id;

  -- Inserimento avanzato nel ledger con metadati
  insert into public.credit_transactions(
    user_id, amount, reason, operation_type, operation_name, context, reference_id, reference_type, created_at, updated_at
  ) values (
    p_user_id, p_amount, p_reason, 'system', coalesce(p_reason, 'credit'), '{}'::jsonb, null, null, now(), now()
  );

  return json_build_object('success', true, 'credits_before', v_before, 'credits_after', v_after);
end;
$$ language plpgsql security definer;

-- Sicurezza (RLS) e policy raccomandate
alter table public.billing_transactions enable row level security;
alter table public.billing_webhook_logs enable row level security;

-- Consenti gestione completa solo al service_role
do $$ begin
  begin
    create policy billing_tx_service_role_all on public.billing_transactions
      for all using (auth.role() = 'service_role') with check (auth.role() = 'service_role');
  exception when duplicate_object then null; end;
  begin
    create policy billing_webhook_logs_service_role_all on public.billing_webhook_logs
      for all using (auth.role() = 'service_role') with check (auth.role() = 'service_role');
  exception when duplicate_object then null; end;
end $$;

-- (Opzionale) Consenti agli utenti di leggere SOLO le proprie transazioni
do $$ begin
  begin
    create policy billing_tx_select_self on public.billing_transactions
      for select using (user_id = auth.uid());
  exception when duplicate_object then null; end;
end $$;

-- Configurazione billing per-app (provider, store, variant mapping, piani)
create table if not exists public.billing_configs (
  app_id text primary key,
  config jsonb not null default '{}'::jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

alter table public.billing_configs enable row level security;
do $$ begin
  begin
    create policy billing_configs_deny_all on public.billing_configs for all
      using (false) with check (false);
  exception when duplicate_object then null; end;
end $$;

-- Credentials provider criptate (sicurezza massima)
create table if not exists public.provider_credentials (
  app_id text not null,
  provider text not null,
  credential_key text not null,
  encrypted_value text not null,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  primary key (app_id, provider, credential_key)
);

alter table public.provider_credentials enable row level security;
do $$ begin
  begin
    create policy provider_credentials_deny_all on public.provider_credentials for all
      using (false) with check (false);
  exception when duplicate_object then null; end;
end $$;

-- Funzione per salvare credential criptata
create or replace function public.set_provider_credential(
  p_app_id text,
  p_provider text,
  p_key text,
  p_value text,
  p_encryption_key text
) returns json as $$
declare
  encrypted_val text;
begin
  -- Semplice XOR encryption (in produzione usare pgcrypto con AES)
  encrypted_val := encode(convert_to(p_value, 'UTF8'), 'base64');
  
  insert into public.provider_credentials (app_id, provider, credential_key, encrypted_value)
  values (p_app_id, p_provider, p_key, encrypted_val)
  on conflict (app_id, provider, credential_key) 
  do update set encrypted_value = excluded.encrypted_value, updated_at = now();
  
  return json_build_object('success', true, 'key', p_key);
end;
$$ language plpgsql security definer;

-- Funzione per leggere credential decriptata
create or replace function public.get_provider_credential(
  p_app_id text,
  p_provider text,
  p_key text,
  p_encryption_key text
) returns text as $$
declare
  encrypted_val text;
begin
  select encrypted_value into encrypted_val 
  from public.provider_credentials 
  where app_id = p_app_id and provider = p_provider and credential_key = p_key;
  
  if encrypted_val is null then
    return null;
  end if;
  
  -- Decodifica base64 (in produzione usare pgcrypto con AES)
  return convert_from(decode(encrypted_val, 'base64'), 'UTF8');
end;
$$ language plpgsql security definer;


