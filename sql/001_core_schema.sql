-- Schema core per Flow Starter (Supabase/Postgres)

-- Tabella profili utente (se non esiste)
create table if not exists public.profiles (
  id uuid primary key,
  email text,
  credits numeric default 0,
  openrouter_api_key text,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now()
);

-- Se la tabella esiste giÃ  senza la colonna, aggiungila (installazioni precedenti)
alter table public.profiles add column if not exists openrouter_api_key text;

-- Tabella ledger transazioni crediti
create table if not exists public.credit_transactions (
  id bigint generated by default as identity primary key,
  user_id uuid not null,
  amount numeric not null,
  reason text,
  created_at timestamp with time zone default now()
);

-- Indice per performance
create index if not exists idx_credit_tx_user_id on public.credit_transactions(user_id);

-- Chiavi OpenRouter per-utente (mapping user -> key_name)
create table if not exists public.openrouter_user_keys (
  user_id uuid primary key,
  key_name text not null,
  created_at timestamp with time zone default now()
);

-- Abilita RLS anche per le chiavi OpenRouter e consenti lettura solo al proprietario
alter table public.openrouter_user_keys enable row level security;
do $$ begin
  begin
    create policy openrouter_keys_select_self on public.openrouter_user_keys
      for select using (user_id = auth.uid());
  exception when duplicate_object then null; end;
end $$;

-- Configurazioni Flowise per multi-tenant: mapping flow_key -> flow_id, node_names per app
create table if not exists public.flow_configs (
  app_id text not null,
  flow_key text not null,
  flow_id text not null,
  node_names jsonb default '[]'::jsonb,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now(),
  primary key (app_id, flow_key)
);

alter table public.flow_configs enable row level security;
-- Policy di esempio: nessun accesso client; accesso solo via service role
do $$ begin
  begin
    create policy flow_configs_deny_all on public.flow_configs for all
      using (false) with check (false);
  exception when duplicate_object then null; end;
end $$;

-- Funzione atomica per addebitare crediti
create or replace function public.debit_user_credits(
  p_user_id uuid,
  p_amount numeric,
  p_reason text default 'debit'
) returns json as $$
declare
  v_before numeric;
  v_after numeric;
begin
  if p_amount is null or p_amount <= 0 then
    return json_build_object('success', false, 'error', 'invalid_amount');
  end if;

  select credits into v_before from public.profiles where id = p_user_id for update;
  if v_before is null then
    return json_build_object('success', false, 'error', 'user_not_found');
  end if;
  if v_before < p_amount then
    return json_build_object('success', false, 'error', 'insufficient_credits', 'available', v_before, 'required', p_amount);
  end if;

  v_after := v_before - p_amount;
  update public.profiles set credits = v_after, updated_at = now() where id = p_user_id;

  insert into public.credit_transactions(user_id, amount, reason)
  values (p_user_id, -p_amount, p_reason);

  return json_build_object('success', true, 'credits_before', v_before, 'credits_after', v_after);
end;
$$ language plpgsql security definer;

-- Policy raccomandate (RLS da adattare al contesto)
alter table public.profiles enable row level security;
alter table public.credit_transactions enable row level security;

-- Esempio policy: accesso in lettura al proprio record (da adattare a auth.uid())
do $$ begin
  begin
    create policy profiles_select_self on public.profiles
      for select using (id = auth.uid());
  exception when duplicate_object then null; end;
  begin
    create policy credit_tx_select_self on public.credit_transactions
      for select using (user_id = auth.uid());
  exception when duplicate_object then null; end;
end $$;


-- Creazione organica profilo alla registrazione (trigger su auth.users)
create or replace function public.handle_new_user_profile()
returns trigger as $$
begin
  insert into public.profiles (id, email, credits, created_at, updated_at)
  values (new.id, new.email, 0, now(), now())
  on conflict (id) do nothing;
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_auth_user_created_profile on auth.users;
create trigger on_auth_user_created_profile
after insert on auth.users
for each row execute function public.handle_new_user_profile();


-- Utility: imposta la chiave OpenRouter nel profilo utente
create or replace function public.set_openrouter_api_key(
  p_user_id uuid,
  p_api_key text
) returns json as $$
begin
  update public.profiles
     set openrouter_api_key = p_api_key,
         updated_at = now()
   where id = p_user_id;
  if not found then
    return json_build_object('success', false, 'error', 'user_not_found');
  end if;
  return json_build_object('success', true);
exception when others then
  return json_build_object('success', false, 'error', SQLERRM);
end;
$$ language plpgsql security definer;


-- =============================================================
-- PRICING PER-APP (single-tenant friendly: usa 'default' come app_id)
-- =============================================================

-- Tabella pricing per-app: configurazione pricing in JSONB
create table if not exists public.pricing_configs (
  app_id text primary key,
  config jsonb not null default '{}'::jsonb,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now()
);

alter table public.pricing_configs enable row level security;
do $$ begin
  begin
    create policy pricing_configs_deny_all on public.pricing_configs for all
      using (false) with check (false);
  exception when duplicate_object then null; end;
end $$;

-- Indici utili
create index if not exists idx_flow_configs_app on public.flow_configs(app_id);
create index if not exists idx_pricing_configs_updated_at on public.pricing_configs(updated_at);
